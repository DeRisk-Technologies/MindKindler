// src/services/document-processing.ts

import { extractDocumentData } from '@/ai/flows/extract-document-data';
import { getRegionalDb } from '@/lib/firebase';
import { doc, updateDoc, arrayUnion, getDoc, setDoc } from 'firebase/firestore';
import { HistoricalAcademicRecord, StudentRecord } from '@/types/schema';

export class DocumentArchaeologist {

    /**
     * Ingests a raw text dump from a school report and maps it to the student's history.
     * @param tenantId - Organization ID
     * @param studentId - Target Student
     * @param region - Data Residency Region
     * @param ocrText - Raw text from the PDF/Image
     * @param sourceFileUrl - Provenance link
     */
    static async processSchoolReport(
        tenantId: string, 
        studentId: string, 
        region: string, 
        ocrText: string,
        sourceFileUrl: string
    ) {
        console.log(`[DocumentArchaeologist] Processing report for ${studentId}...`);

        // 1. AI Extraction
        const result = await extractDocumentData({
            documentText: ocrText,
            category: 'school_report'
        });

        console.log(`[DocumentArchaeologist] AI Extraction complete. Confidence: ${result.confidence}`);

        // 2. Validation
        if (result.confidence < 0.4) {
            console.warn("Low confidence extraction. Flagging for review.");
            // We still proceed but might mark metadata as low confidence
        }

        const data = result.extractedData as any;
        const records = data.records || [];
        const academicYear = data.academicYear || new Date().getFullYear().toString();

        if (records.length === 0) {
            return { success: false, message: "No academic records found in text." };
        }

        // 3. Map to Schema
        const newHistoryItems: HistoricalAcademicRecord[] = records.map((rec: any) => ({
            id: `hist_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            studentId,
            academicYear: academicYear,
            term: rec.term || DocumentArchaeologist.inferTerm(rec.date),
            subject: rec.subject || 'General',
            grade: rec.grade || 'N/A',
            maxGrade: rec.maxGrade, // Optional if AI finds it
            type: 'Term', // Default assumption
            source: 'OCR Import',
            date: rec.date || new Date().toISOString(),
            metadata: {
                source: 'ocr',
                sourceId: sourceFileUrl,
                confidence: result.confidence,
                verified: false, 
                autoGenerated: true
            }
        }));

        // 4. Persistence (Regional Shard)
        const db = getRegionalDb(region);
        const studentRef = doc(db, 'students', studentId);
        
        try {
            const snap = await getDoc(studentRef);
            if (!snap.exists()) throw new Error("Student not found");

            const studentData = snap.data() as StudentRecord;
            
            // Initialize timeline if missing
            if (!studentData.timeline) {
                await updateDoc(studentRef, {
                    timeline: {
                        academic: newHistoryItems,
                        attendance: [],
                        behavior: []
                    }
                });
            } else {
                // Append to existing array
                await updateDoc(studentRef, {
                    "timeline.academic": arrayUnion(...newHistoryItems)
                });
            }

            return {
                success: true,
                processedCount: newHistoryItems.length,
                records: newHistoryItems,
                summary: result.summary
            };

        } catch (e: any) {
            console.error("Failed to save history:", e);
            return { success: false, error: e.message };
        }
    }

    /**
     * Helper to guess term from date.
     */
    private static inferTerm(dateStr?: string): string {
        if (!dateStr) return 'Unknown';
        const date = new Date(dateStr);
        if (isNaN(date.getTime())) return 'Unknown';
        
        const month = date.getMonth(); // 0-11
        if (month >= 8 && month <= 11) return 'Autumn'; // Sept-Dec
        if (month >= 0 && month <= 3) return 'Spring'; // Jan-April
        return 'Summer'; // May-Aug
    }
}
